## 컴퓨터 내부의 언어 체계 p.52

### 언어란 무엇인가 p.52
1. 모든 언어의 뜻은 기호의 집합으로 인코딩된다. 그리고 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥(Context)을 공유해서
같은 기호에 같은 뜻을 부여할 수 있어야 한다.

### 드모르간 법칙 p.56
1. 드모르간 법칙에선 a AND b 은 NOT(NOT a OR NOT b) 와 같다.
   <br/><br/>
2. 이 말은 NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다. ( 반대로 OR을 AND로 대신할 수 있다. )
   <br/><br/>
3. 긍정적인 논리(positive logic)에 더해 부정적인 논리(negative logic)를 기술하는 명제를 사용할 때 드모르간의 법칙을 사용할 수 있다.
   <br/><br/>
4. (춥다 OR 비가 온다)를 (NOT 춥다 AND NOT 비가 온다)와 같이 긍정적인 논리를 부정적인 논리로 변환한다.
만약 드모르간 법칙이 없었다면 ( NOT NOT 춥다 OR NOT NOT 비가 온다 )로 OR을 사용해야 했을 것이다.

### 2진수 덧셈 p.61
1. 2개의 숫자를 더할 때 가능한 경우의 수가 10진수 에서는 백 가지이나 2진수에서는 네 가지밖에 안 되기 때문에, 실제로는 2진수 덧셈이 좀 더 쉽다.
   <br/><br/>
2. 001 + 101을 하려면 가장 오른쪽 LSB부터 더하기 시작한다. 그리고 더하기 연산을 할 땐 AND와 XOR을 사용한다.
예를 들어 LSB에서 연산은 1 AND 1 -> 1 0 <- 1 XOR 1 와 같이 연산을 수행한다.
   <br/><br/>
3. 덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 오버플로란 MSB에서 올림이 발생했다는 뜻이다.
   <br/><br/>
4. 컴퓨터에는 조컨 코드(또는 상태 코드) 레지스터(condition code register)라는 것이 있어서 몇 가지 이상한 정보를 담아둔다.
이런 정보 중에는 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 이 비트값을 보면 오버플로가 발생했는지 알 수 있다.
MSB에서 위쪽에서 1을 빌려오는 경우를 언더플로라고 부른다. 이에 해당하는 조건 코드도 컴퓨터에 들어 있다.

### 부호와 크기 p.63
1. 음수와 양수를 구별하기 위해 흔히 부호를 사용한다. 우리들은 가장 왼쪽 비트(MSB)를 부호에 사용하기로 결정했다. 이런 방법을 부호와 크기 표현법이라 한다.
이 방법은 두 가지 이유로 널리 쓰이지 못하고 있다. 첫째, 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다.
둘째, 부호와 크기 표현법을 사용하려면 XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.

### 1의 보수 p.64
1. 음수를 표현하기 위해 양수의 모든 비트를 뒤집는 방법을 1의 보수 표현법이라 한다. 0111(7)을 1의 보수 표현법으로 음수로 변환하면 1000(-7)이 된다.
   <br/><br/>
2. 이 표현법도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 게다가 1의 보수에서도 덧셈을 쉽게 할 수 없다. 이 문제를 해결하려면 순환 올림이 필요하다.
   <br/><br/>
3. 순환 올림은 MSB에서 올림이 발생한 경우 LSB로 올림을 전달한다. 0010(+2) + 1110(-1)은 오버플로로 0000이 되어야 하지만 순환 올림으로 0001이 된다.
   <br/><br/>
4. 하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 하기 때문에 좋은 해법은 아니다.

### 2의 보수 p.66
1. 특별한 하드웨어 추가없이 XOR와 AND만을 사용하는 방법은 2의 보수 표현법이다.
   <br/><br/>
2. 0001(+1)에 덧셈을 했을 때 0이 나오는 비트 패턴을 -1이라 불러보자. 4비트 수의 경우에선 1111(-1)이다. 이런 표현법을 2의 보수 표현법이라 한다.
   <br/><br/>
3. 이 표현법에선 MSB 올림이 발생하면 해당 값을 버린다.